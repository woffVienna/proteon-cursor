# Proteon Cursor Rules

These rules are mandatory for any code generation or refactor in this
repository.

------------------------------------------------------------------------

# Source of truth

-   Follow `/ENGINEERING.md` strictly.
-   If there is a conflict between a request and ENGINEERING.md, flag it
    and propose an alternative.

------------------------------------------------------------------------

# Repo architecture

-   Monorepo with independent Go modules per service under
    `/services/<service>`.
-   NEVER import code from another service (no cross-service imports).
-   Cross-service interaction is via HTTP or events only.

------------------------------------------------------------------------

# Layering & dependency direction (per service)

Enforce strict dependency direction:

adapters → application → domain

Never the reverse.

## Domain (`internal/domain`)

-   Pure.
-   Standard library only (default).
-   No adapters, no platform, no HTTP/DB/NATS/framework dependencies.
-   Do not import OpenAPI generated types.
-   Prefer pure functions and behavior on domain models.

## Application (`internal/application`)

-   May import domain and `libs/platform`.
-   Must not import adapters or OpenAPI generated types.
-   Boundary interfaces live in `internal/application/interfaces`.
-   Application services must be struct-based with constructor
    functions.
-   Prefer cohesive service structs with receiver methods over
    standalone functions.

## Adapters (`internal/adapters`)

-   Implement application interfaces.
-   Own mapping between transport/infrastructure types and application
    DTOs.
-   May import external frameworks (HTTP, DB, NATS, etc.).
-   Use struct-based implementations (e.g. repositories, handlers,
    clients).

## Platform (`internal/platform`)

-   Technical wiring only (config, health, shutdown, buildinfo).
-   No business logic.

------------------------------------------------------------------------

# Coding Style (Mandatory)

## General

-   Prefer struct-based design with constructor functions and receiver
    methods.
-   Avoid large standalone functions that pass many dependencies as
    parameters.
-   Group related behavior inside cohesive types.

Example preferred pattern:

type Service struct { repo Repository logger Logger }

func NewService(repo Repository, logger Logger) \*Service { return
&Service{repo: repo, logger: logger} }

func (s \*Service) Execute(ctx context.Context, input Input) error { ...
}

## Avoid

-   Large standalone functions that pass many dependencies as
    parameters.
-   "Function soup" orchestration across layers unless the function is
    truly pure and stateless.

## When to use pure functions

-   Domain logic
-   Stateless mappers
-   Validation helpers
-   Small utility helpers

## When to use struct + methods

-   Application services
-   Repositories
-   HTTP handler sets
-   Background jobs / schedulers
-   External clients
-   Configuration loaders

Application services, repositories, handlers, schedulers, and clients
must be struct-based.

------------------------------------------------------------------------

# Configuration

-   Core configuration is provided by environment variables.
-   Runtime configuration is loaded from DB.
-   Configuration is resolved once at service startup.
-   No runtime mutation of configuration.
-   Shared configuration loading/orchestration lives in `libs/platform`.
-   Service-specific config structs live in the service.

------------------------------------------------------------------------

# OpenAPI / code generation

-   OpenAPI source lives in `services/<svc>/api/openapi.yml`.
-   Shared OpenAPI fragments live in `/libs/api/openapi` (refer via
    `$ref`).
-   Bundle output goes into:
    `services/<svc>/.build/generated/openapi.bundle.yml` and is NOT
    committed.
-   Generated Go server stubs go into:
    `services/<svc>/internal/adapters/http/generated/server/openapi.gen.go`.
-   Generated Go code IS committed.

------------------------------------------------------------------------

# Build artifacts

-   All build artifacts go to `services/<svc>/.build` (including
    binaries in `.build/bin`).
-   Do not create `node_modules` outside `tools/node`.

------------------------------------------------------------------------

# Tooling

-   Node tooling lives under `/tools/node` (Redocly).
-   Go tools live under `/tools/bin` (oapi-codegen, golangci-lint).
-   Docker assets live under `/tools/docker`.
-   Prefer Make targets (root and service-level) over ad-hoc commands.

------------------------------------------------------------------------

# Output expectations for changes

-   Keep changes minimal and consistent with existing style.
-   When adding new code:
    -   Place it in the correct layer.
    -   Add necessary wiring in `cmd/<svc>/main.go` only.
-   If generated code requires new Go deps:
    -   Ensure module is tidy (`go mod tidy`).
    -   Ensure build remains green.
-   Do not introduce new layers, patterns, or architectural concepts
    unless explicitly requested.

------------------------------------------------------------------------

# When uncertain

-   Ask a clarifying question OR state assumptions explicitly before
    implementing.
-   Never invent new repo structure, naming conventions, or layers not
    present in ENGINEERING.md.
